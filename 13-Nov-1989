Newsgroups: news.software.b
Subject: 13-Nov-1989 patch for C News

There are two big items in this.  First, relaynew's sys-file handling has
been revised to eliminate a slow memory leak.  Second, Geoff has done a
substantial portability-and-robustness overhaul on the Aussie readnews.

Also...  The batcher now logs both start time and end time for a batching
run, so you can see how long it took.  Newsrunning with no argument now
prints the current state, so a save/restore is possible.  The RFC-errata
document more fully discusses the two areas where C News's compliance is
(according to some) debatable.  (The comment on rfc822ize() has also been
expanded.)  Adddirs now disregards newsgroups marked with "x" or "=", and
actually [blush!] makes the directories it's supposed to make.  Newsdaily
now notes space shortages and reports on unmoderated articles in groups
that your active file thinks are moderated.  Tolerance of syntactically-
illegal message-ids has been reduced.  Relaynews now does a sanity check
on MAXLONG, the definition of which trips up some compilers.  There is
also the usual scattering of minor cleanups.

Finally, the patch-preparation process has been revised to avoid the
14-Sep-1989 problems, and in particular the patch (not just the files
that went into preparing it) has been tested.

start of patch 13-Nov-1989
(suggested archive name: `pch13Nov89.Z')
this should be run with   patch -p0 <thisfile

The following is a complete list of patches to date.

Prereq: 23-Jun-1989
Prereq: 7-Jul-1989
Prereq: 23-Jul-1989
Prereq: 22-Aug-1989
Prereq: 24-Aug-1989
Prereq: 14-Sep-1989
*** PATCHDATES.old	Mon Nov 13 16:23:36 1989
--- PATCHDATES	Mon Nov 13 16:23:36 1989
***************
*** 1,6 ****
--- 1,7 ----
  23-Jun-1989
  7-Jul-1989
  23-Jul-1989
  22-Aug-1989
  24-Aug-1989
  14-Sep-1989
+ 13-Nov-1989

Changed files, if any:

*** cnpatch/old/batch/Makefile	Thu Sep 14 16:03:25 1989
--- batch/Makefile	Tue Oct 31 17:49:05 1989
***************
*** 161,167 ****
  	test ! -s out.going/bar/togo ;
  	cmp test.left out.going/bar/togo.2
! 	sed '/^$$/q' batchlog | sed '1d;$$d' >test.log
  	test ! -s test.log ;
! 	sed '1,/^$$/d' batchlog | sed '1d;$$d' >test.log
  	echo 'bar	backlog 1 (batches flowing)' >test.good
  	cmp test.good test.log
--- 161,167 ----
  	test ! -s out.going/bar/togo ;
  	cmp test.left out.going/bar/togo.2
! 	sed '/^$$/q' batchlog | sed '1d;$$d' | sed '$$d' >test.log
  	test ! -s test.log ;
! 	sed '1,/^$$/d' batchlog | sed '1d;$$d' | sed '$$d' >test.log
  	echo 'bar	backlog 1 (batches flowing)' >test.good
  	cmp test.good test.log

*** cnpatch/old/batch/sendbatches	Tue Aug 22 14:47:39 1989
--- batch/sendbatches	Wed Sep 20 22:05:31 1989
***************
*** 177,179 ****
--- 177,180 ----
  done
  
+ date >>$log
  echo >>$log

*** cnpatch/old/conf/build	Thu Sep 14 16:03:26 1989
--- conf/build	Mon Nov 13 14:59:43 1989
***************
*** 825,828 ****
--- 825,829 ----
  	echo '#! /bin/sh'
  	echo '# -i suppresses install, -t suppresses stdio test, -s suppresses subst'
+ 	echo '# options are seen in first argument only, i.e. use -si not -s -i'
  	echo "umask $newsumask"
  	echo "set -x"

*** cnpatch/old/expire/expire.c	Thu Sep 14 16:03:30 1989
--- expire/expire.c	Thu Sep 14 23:39:41 1989
***************
*** 435,439 ****
  	datum rhs;
  	register int ret;
- 	register char *id;
  
  	cd(ctlfile((char *)NULL));
--- 435,438 ----

*** cnpatch/old/h/libc.h	Thu Sep 14 16:03:35 1989
--- h/libc.h	Sun Sep 17 16:42:07 1989
***************
*** 56,60 ****
  extern FILE *popen();			/* stdio.h */
  #ifdef __STDC__
! extern int printf(char *fmt, ...)	/* stdio.h */
  extern int fprintf(FILE *fp, char *fmt, ...);		/* stdio.h */
  extern sprvalue sprintf(char *buf, char *fmt, ...);	/* stdio.h */
--- 56,60 ----
  extern FILE *popen();			/* stdio.h */
  #ifdef __STDC__
! extern int printf(char *fmt, ...);	/* stdio.h */
  extern int fprintf(FILE *fp, char *fmt, ...);		/* stdio.h */
  extern sprvalue sprintf(char *buf, char *fmt, ...);	/* stdio.h */

*** cnpatch/old/h/news.h	Thu Aug 24 16:39:52 1989
--- h/news.h	Mon Oct 30 13:22:31 1989
***************
*** 102,105 ****
--- 102,107 ----
  #define NO 0
  
+ #define SIZENUL (sizeof(char))		/* size in bytes of an ASCII NUL byte */
+ 
  #define NOTALLHDRS NO			/* hdrdump flags for "all headers seen?" */
  #define ALLHDRS YES

*** cnpatch/old/input/newsrunning	Tue Jun 20 18:58:15 1989
--- input/newsrunning	Fri Nov  3 15:09:26 1989
***************
*** 23,28 ****
  	;;
  
  	*)
! 	echo "Usage: $0 on/off" >&2
  	exit 2
  	;;
--- 23,37 ----
  	;;
  
+ 	'')
+ 	if test -r $stop
+ 	then
+ 		echo off
+ 	else
+ 		echo on
+ 	fi
+ 	;;
+ 
  	*)
! 	echo "Usage: $0 [on/off]" >&2
  	exit 2
  	;;

*** cnpatch/old/libbig/sys.fast.c	Tue Jun 20 18:58:24 1989
--- libbig/sys.fast.c	Thu Oct  5 05:14:57 1989
***************
*** 11,26 ****
  extern struct system *currsys, *firstsys;
  
- /* exports */
- boolean justone = NO;
- 
  /* private */
  static struct system *thissys = NULL;
  
- /* ARGSUSED */
  void
! rewsys(fp)
! FILE *fp;
  {
! 	currsys = firstsys;
  }
  
--- 11,22 ----
  extern struct system *currsys, *firstsys;
  
  /* private */
  static struct system *thissys = NULL;
  
  void
! remmysys(sys)				/* remember this system */
! struct system *sys;
  {
! 	thissys = sys;
  }
  
***************
*** 32,44 ****
  
  void
! remmysys(sys)				/* remember this system */
! struct system *sys;
  {
! 	thissys = sys;
  }
  
  void
! freecurrsys()
  {
! 	/* never free sys entries */
  }
--- 28,55 ----
  
  void
! setupsys(fp)
! FILE *fp;
  {
! 	rewind(fp);
  }
  
+ boolean
+ donesys()
+ {
+ 	return NO;
+ }
+ 
+ /* ARGSUSED */
  void
! rewsys(fp)
! FILE *fp;
  {
! 	currsys = firstsys;
! }
! 
! void
! advcurrsys()	/* advance currsys to the next in-core sys entry, if any. */
! {
! 	if (currsys != NULL)
! 		currsys = currsys->sy_next;
  }

*** cnpatch/old/libcnews/case.c	Thu Sep 14 16:03:37 1989
--- libcnews/case.c	Mon Oct 30 16:59:03 1989
***************
*** 88,91 ****
--- 88,100 ----
  /*
   - rfc822ize - do the bizarre case conversion needed for rfc822 message-ids
+  *
+  * Actually, this is not quite complete.  Absolute, total, full RFC822
+  * compliance requires a horrible parsing job, because of the arcane
+  * quoting conventions -- abc"def"ghi is not equivalent to abc"DEF"ghi,
+  * for example.  There are three or four things that might occur in the
+  * domain part of a message-id that are case-sensitive.  They don't seem
+  * to ever occur in real news, thank Cthulhu.  (What?  You were expecting
+  * a merciful and forgiving deity to be invoked in connection with RFC822?
+  * Forget it; none of them would come near it.)
   */
  char *				/* returns the argument */

*** cnpatch/old/libsmall/sys.slow.c	Tue Jun 20 18:59:34 1989
--- libsmall/sys.slow.c	Thu Oct  5 05:14:23 1989
***************
*** 8,17 ****
  #include "system.h"
  
- /* exports */
- boolean justone = YES;
- 
  /* imports */
  extern struct system *currsys, *firstsys;
  
  struct system *
  mysysincache()
--- 8,24 ----
  #include "system.h"
  
  /* imports */
  extern struct system *currsys, *firstsys;
  
+ /* forwards */
+ FORWARD void freecurrsys();
+ 
+ void
+ remmysys(sys)
+ struct system *sys;
+ {
+ 	/* no cache */
+ }
+ 
  struct system *
  mysysincache()
***************
*** 20,30 ****
  }
  
  void
! remmysys(sys)
! struct system *sys;
  {
! 	/* no cache */
  }
  
  void
  rewsys(fp)
--- 27,48 ----
  }
  
+ /* ARGSUSED */
  void
! setupsys(fp)				/* reuse currsys */
! FILE *fp;
  {
! 	freecurrsys();
  }
  
+ boolean
+ donesys()
+ {
+ 	if (firstsys != NULL) {		/* parsed an entry? */
+ 		firstsys = NULL;	/* not cached, but currsys still valid */
+ 		return YES;
+ 	} else
+ 		return NO;		/* was a comment */
+ }
+ 
  void
  rewsys(fp)
***************
*** 35,49 ****
  }
  
  /*
   * Free current sys entry & associated memory.  Zero currsys too.
   */
! void
  freecurrsys()
  {
! 	if (currsys == NULL)
! 		return;
! 	nnfree(&currsys->sy_name);
! 	nnfree(&currsys->sy_ngs);
! 	nnfree(&currsys->sy_cmd);
! 	nnafree(&currsys);
  }
--- 53,78 ----
  }
  
+ void
+ advcurrsys()
+ {
+ 	/*
+ 	 * the sys file is not in core, so we must not change currsys
+ 	 * to ensure that it gets freed later by freecurrsys().
+ 	 */
+ }
+ 
  /*
   * Free current sys entry & associated memory.  Zero currsys too.
   */
! STATIC void
  freecurrsys()
  {
! 	if (currsys != NULL) {
! 		nnfree(&currsys->sy_name);
! 		nnfree(&currsys->sy_excl);
! 		nnfree(&currsys->sy_ngs);
! 		nnfree(&currsys->sy_distr);
! 		nnfree(&currsys->sy_cmd);
! 		nnafree(&currsys);
! 	}
  }

*** cnpatch/old/libstdio/fgets.c	Thu Sep 14 16:03:39 1989
--- libstdio/fgets.c	Tue Oct  3 00:58:19 1989
***************
*** 75,84 ****
  		 */
  		{
! 			register int copy;
  
- 			if (nlp == NULL)
- 				copy = origbytesleft;
- 			else
- 				copy = nlp - (char *)fp->_ptr;
  			lim -= copy;
  			fp->_cnt -= copy;
--- 75,81 ----
  		 */
  		{
! 			register int copy = (nlp == NULL?
! 				origbytesleft: nlp - (char *)fp->_ptr);
  
  			lim -= copy;
  			fp->_cnt -= copy;

*** cnpatch/old/man/newsaux.8	Thu Sep 14 16:03:42 1989
--- man/newsaux.8	Fri Sep 15 13:19:38 1989
***************
*** 7,11 ****
  .\" =()<.ds m @<NEWSMASTER>@>()=
  .ds m usenet
! .TH NEWSAUX 8 "13 Sept 1989" "C News"
  .SH NAME
  spacefor \- check available space for news
--- 7,11 ----
  .\" =()<.ds m @<NEWSMASTER>@>()=
  .ds m usenet
! .TH NEWSAUX 8 "15 Sept 1989" "C News"
  .SH NAME
  spacefor \- check available space for news
***************
*** 150,154 ****
  for easier processing.
  Canonicalization forces all alphabetics to lower case except the first
! letter of the keyword, which is forced to upper case.
  (One exception:
  ``Message-ID'' is the canonical form of [e.g.] ``message-id''.)
--- 150,155 ----
  for easier processing.
  Canonicalization forces all alphabetics to lower case except the first
! letter of each (hyphen-separated) word in the keyword,
! which is forced to upper case.
  (One exception:
  ``Message-ID'' is the canonical form of [e.g.] ``message-id''.)

*** cnpatch/old/man/rnews.8	Sun Jul 23 00:48:11 1989
--- man/rnews.8	Fri Nov  3 15:15:21 1989
***************
*** 7,11 ****
  .\" =()<.ds m @<NEWSMASTER>@>()=
  .ds m usenet
! .TH RNEWS 8 "14 July 1989" "C News"
  .SH NAME
  rnews, cunbatch \- accept and spool news input
--- 7,11 ----
  .\" =()<.ds m @<NEWSMASTER>@>()=
  .ds m usenet
! .TH RNEWS 8 "3 Nov 1989" "C News"
  .SH NAME
  rnews, cunbatch \- accept and spool news input
***************
*** 29,33 ****
  .br
  .B \*b/input/newsrunning
! {\fBon\fR|\fBoff\fR}
  .SH DESCRIPTION
  .I Rnews
--- 29,33 ----
  .br
  .B \*b/input/newsrunning
! [\fBon\fR|\fBoff\fR]
  .SH DESCRIPTION
  .I Rnews
***************
*** 55,60 ****
  should be run periodically (e.g. by \fIcron\fR(8)) to process spooled news.
  .I Newsrunning
! can be used to enable and disable \fInewsrun\fR's processing if it is desired
  to avoid major news processing during certain hours.
  .PP
  .I Newsrun
--- 55,66 ----
  should be run periodically (e.g. by \fIcron\fR(8)) to process spooled news.
  .I Newsrunning
! can be used to turn \fInewsrun\fR's processing off and on if it is desired
  to avoid major news processing during certain hours.
+ `\fBnewsrunning off\fR' instructs any currently-running \fInewsrun\fR to
+ stop as soon as possible, and prevents later ones from running.
+ `\fBnewsrunning on\fR' removes the inhibition (but does not actually
+ start a new \fInewsrun\fR).
+ Without an argument, \fInewsrunning\fR reports the current status:
+ ``off'' or ``on''.
  .PP
  .I Newsrun

*** cnpatch/old/misc/adddirs	Tue Aug 22 14:47:37 1989
--- misc/adddirs	Mon Sep 18 18:21:58 1989
***************
*** 8,12 ****
  umask $NEWSUMASK
  
! for dir in `sed 's/[ 	].*//' $NEWSCTL/active | tr . /`
  do
  	if test ! -d $NEWSARTS/$dir
--- 8,12 ----
  umask $NEWSUMASK
  
! for dir in `awk '$4 !~ /^[x=]/ { print $1 }' $NEWSCTL/active | tr . /`
  do
  	if test ! -d $NEWSARTS/$dir
***************
*** 13,17 ****
  	then
  		echo "making $dir (and parents if needed...)"
! 		: mkpdir $NEWSARTS/$dir
  	fi
  done
--- 13,17 ----
  	then
  		echo "making $dir (and parents if needed...)"
! 		mkpdir $NEWSARTS/$dir
  	fi
  done

*** cnpatch/old/misc/delgroup	Tue Jun 20 19:00:10 1989
--- misc/delgroup	Wed Nov  8 14:23:38 1989
***************
*** 46,48 ****
  mv active active.old && mv active.tmp active
  
! echo "You may wish to rm -rf $NEWSARTS/`echo "$1" | sed 's;\.;/;g'` at some point."
--- 46,48 ----
  mv active active.old && mv active.tmp active
  
! echo "You may wish to rmdir $NEWSARTS/`echo "$1" | sed 's;\.;/;g'` at some point."

*** cnpatch/old/misc/getdate.c	Tue Jun 20 19:00:06 1989
--- misc/getdate.c	Tue Oct 31 15:58:40 1989
***************
*** 74,78 ****
  	it = getdate(tm, &ftnow);
  	if (it < 0)
! 		error("`%s' not valid date", tm);
  	else
  		(void) printf("%ld\n", it);
--- 74,78 ----
  	it = getdate(tm, &ftnow);
  	if (it < 0)
! 		(void) fprintf(stderr, "%s: `%s' not a valid date\n", progname, tm);
  	else
  		(void) printf("%ld\n", it);

*** cnpatch/old/misc/newsdaily	Tue Aug 22 14:47:48 1989
--- misc/newsdaily	Sat Nov  4 15:11:16 1989
***************
*** 29,33 ****
  
  # keep one generation of log -- it's big
! rm log.o
  mv log log.o && >log
  
--- 29,33 ----
  
  # keep one generation of log -- it's big
! rm -f log.o
  mv log log.o && >log
  
***************
*** 84,89 ****
  	) >>$gripes
  fi
  
! # look for unknown newsgroups on input (misses cross-posted articles)
  cd $NEWSCTL
  egrep '`' log.o | egrep junked | sed 's/.*`\(.*\)'"'"'.*/\1/' | sort |
--- 84,98 ----
  	) >>$gripes
  fi
+ cd $NEWSCTL
+ no=`egrep 'disk too full' batchlog.o | wc -l`
+ if test " $no" -gt 0
+ then
+ 	(
+ 		echo "space shortage(s) limited batching $no times"
+ 		echo
+ 	) >>$gripes
+ fi
  
! # look for problem newsgroups on input (can miss cross-posted articles)
  cd $NEWSCTL
  egrep '`' log.o | egrep junked | sed 's/.*`\(.*\)'"'"'.*/\1/' | sort |
***************
*** 93,96 ****
--- 102,115 ----
  	(
  		echo 'leading five unknown newsgroups by number of articles:'
+ 		cat $tmp
+ 		echo
+ 	) >>$gripes
+ fi
+ egrep '`' log.o | egrep unapproved | sed 's/.*`\(.*\)'"'"'.*/\1/' | sort |
+ 	uniq -c | sort -nr | sed 5q >$tmp
+ if test -s $tmp
+ then
+ 	(
+ 		echo 'top five supposedly-moderated groups with unmoderated postings:'
  		cat $tmp
  		echo

*** cnpatch/old/notebook/rfcerrata	Tue Jun 20 18:56:30 1989
--- notebook/rfcerrata	Mon Nov 13 16:09:15 1989
***************
*** 68,78 ****
  .PP
  RFC 1036
! claims that
  .I cancel
! control messages should stop propagating when their target messages
! are not present;
! it would improve the efficacy of
! .I cancel s
! to propagate them anyway.
  .SH
  ihave/sendme not documented
--- 68,88 ----
  .PP
  RFC 1036
! says that
  .I cancel
! control messages should stop propagating if the receiving system
! is ``unable to cancel the message as requested''.
! It is not clear what this means, given that modern news systems hang
! onto cancellations for not-yet-seen articles in hopes of being able
! to cancel them in the future.
! B 2.11 interprets absence of the target article as ``unable to cancel''.
! It would improve the efficacy and reliability of
! .IR cancel s
! to propagate them anyway, given that feed anomalies are widespread.
! There have been verified instances in which cancellations did not achieve
! anywhere near the propagation of the original article.
! In the interests of robustness,
! C News interprets absence of the target article as deferred cancellation
! rather than failure to cancel, and propagates the
! .IR cancel .
  .SH
  ihave/sendme not documented
***************
*** 94,95 ****
--- 104,119 ----
  or a
  .I remotesys .
+ .SH
+ case-sensitivity in message-ids
+ .PP
+ RFC 1036 says nothing about whether message-ids are case-sensitive or not,
+ thereby punting the issue to RFC 822.
+ The RFC 822 rules are horrendously complex and no news system has ever
+ implemented them correctly.
+ (B 2.10 considers them fully case-sensitive, which is wrong.
+ B 2.11 considers them fully case-insensitive, which is also wrong.
+ C News gets the normal case right, but correct handling of certain
+ obscure RFC 822 constructs would
+ require a complex parsing algorithm; fortunately, the cases where this
+ matters appear to be extremely rare.)
+ Simplification appears necessary.

*** cnpatch/old/relay/hdrparse.c	Thu Sep 14 16:03:48 1989
--- relay/hdrparse.c	Mon Sep 18 18:19:59 1989
***************
*** 60,63 ****
--- 60,66 ----
   * then the strsave calls need to check for failure.
   *
+  * An article lacking a Message-ID: but possessing an (obsolete)
+  * Article-I.D.: gets the transformed Article-I.D. as its Message-ID:.
+  *
   * We support control message *backwards* compatibility: if no Control:
   * header exists and the newsgroup matches all.all.ctl, use the Subject:
***************
*** 72,92 ****
  	if (hdrs->h_distr == NULL)
  		hdrs->h_distr = strsave(DEFDIST);
! 	if (hdrs->h_msgid == NULL && hdrs->h_artid != NULL)	/* obs. art.id. */
! 		hdrs->h_msgid = strsave(hdrs->h_artid);
! 	if (hdrs->h_msgid == NULL)
  		hdrs->h_msgid = strsave(DEFMSGID);
- 	if (hdrs->h_msgid[0] == '\0') {
- 		free(hdrs->h_msgid);
- 		hdrs->h_msgid = strsave(DEFMSGID);
  	}
! 	if (hdrs->h_expiry == NULL)
  		hdrs->h_expiry = strsave(DEFEXP);
- 	if (hdrs->h_expiry[0] == '\0') {
- 		free(hdrs->h_expiry);
- 		hdrs->h_expiry = strsave(DEFEXP);
  	}
  	if (hdrs->h_subj == NULL)
  		hdrs->h_subj = strsave("");
- 
  	if (hdrs->h_ctlcmd == NULL && oldctl(hdrs))
  		hdrs->h_ctlcmd = strsave(hdrs->h_subj);
--- 75,93 ----
  	if (hdrs->h_distr == NULL)
  		hdrs->h_distr = strsave(DEFDIST);
! 
! 	if (hdrs->h_msgid == NULL && hdrs->h_artid != NULL)
! 		hdrs->h_msgid = str3save("<", hdrs->h_artid, ">");
! 	if (hdrs->h_msgid == NULL || hdrs->h_msgid[0] == '\0') {
! 		nnfree(&hdrs->h_msgid);
  		hdrs->h_msgid = strsave(DEFMSGID);
  	}
! 
! 	if (hdrs->h_expiry == NULL || hdrs->h_expiry[0] == '\0') {
! 		nnfree(&hdrs->h_expiry);
  		hdrs->h_expiry = strsave(DEFEXP);
  	}
+ 
  	if (hdrs->h_subj == NULL)
  		hdrs->h_subj = strsave("");
  	if (hdrs->h_ctlcmd == NULL && oldctl(hdrs))
  		hdrs->h_ctlcmd = strsave(hdrs->h_subj);

*** cnpatch/old/relay/makefile	Thu Sep 14 16:03:49 1989
--- relay/makefile	Fri Sep 15 13:55:22 1989
***************
*** 49,53 ****
  
  all: makefile relaynews
! 	chmod +x sh/* aux/* ctl/*
  
  mkfile: makefile
--- 49,53 ----
  
  all: makefile relaynews
! 	chmod +x sh/[a-z]* aux/[a-z]* ctl/[a-z]*
  
  mkfile: makefile
***************
*** 72,78 ****
  	cp relaynews $(NEWSBIN)/relay
  	: needs to be news-owned, setuid -- build looks after that
! 	cp sh/* $(NEWSBIN)/inject
! 	cp ctl/* $(NEWSBIN)/ctl
! 	cp aux/* $(NEWSBIN)/relay
  	rm -f $(BIN)/inews
  	ln $(NEWSBIN)/inject/inews $(BIN)/inews 2>/dev/null || cp sh/inews $(BIN)
--- 72,78 ----
  	cp relaynews $(NEWSBIN)/relay
  	: needs to be news-owned, setuid -- build looks after that
! 	cp sh/[a-z]* $(NEWSBIN)/inject
! 	cp ctl/[a-z]* $(NEWSBIN)/ctl
! 	cp aux/[a-z]* $(NEWSBIN)/relay
  	rm -f $(BIN)/inews
  	ln $(NEWSBIN)/inject/inews $(BIN)/inews 2>/dev/null || cp sh/inews $(BIN)

*** cnpatch/old/relay/procart.c	Thu Sep 14 16:03:49 1989
--- relay/procart.c	Mon Sep 18 18:20:00 1989
***************
*** 294,312 ****
  register struct article *art;
  {
! 	if (art->h.h_path == NULL) {
  		prefuse(art);
  		(void) printf("no Path: header\n");
! 	} else if (art->h.h_msgid == NULL || art->h.h_msgid[0] == '\0') {
  		prefuse(art);
  		(void) printf("missing Message-ID\n");
! 	} else if (strchr(art->h.h_msgid, ' ') != NULL ||
! 	   strchr(art->h.h_msgid, '\t') != NULL) {
  		prefuse(art);
  		(void) printf("whitespace in Message-ID\n");
! 	} else if (alreadyseen(art->h.h_msgid)) {
  		prefuse(art);
  		(void) printf("duplicate\n");
! 	} else if (art->h.h_path != NULL && hopcount(art->h.h_path) > 0 &&
! 	    !ngmatch(oursys()->sy_ngs, art->h.h_ngs)) {
  		extern boolean histreject;
  
--- 294,318 ----
  register struct article *art;
  {
! 	register char *msgid = art->h.h_msgid;
! 	register char *path =  art->h.h_path;
! 	register char *ngs =   art->h.h_ngs;
! 
! 	if (path == NULL) {
  		prefuse(art);
  		(void) printf("no Path: header\n");
! 	} else if (msgid == NULL || msgid[0] == '\0') {
  		prefuse(art);
  		(void) printf("missing Message-ID\n");
! 	} else if (strchr(msgid, ' ') != NULL || strchr(msgid, '\t') != NULL) {
  		prefuse(art);
  		(void) printf("whitespace in Message-ID\n");
! 	} else if (msgid[0] != '<' || msgid[strlen(msgid)-1] != '>') {
  		prefuse(art);
+ 		(void) printf("<> brackets missing in Message-ID\n");
+ 	} else if (alreadyseen(msgid)) {
+ 		prefuse(art);
  		(void) printf("duplicate\n");
! 	} else if (path != NULL && hopcount(path) > 0 &&
! 	    !ngmatch(oursys()->sy_ngs, ngs)) {
  		extern boolean histreject;
  
***************
*** 319,327 ****
  			history(art, NOLOG);
  		prefuse(art);
! 		(void) printf("no subscribed groups in `%s'\n", art->h.h_ngs);
! 	} else if (art->h.h_approved == NULL && moderated(art->h.h_ngs)) {
  		prefuse(art);
  		(void) printf("unapproved article in moderated group(s) `%s'\n",
! 			art->h.h_ngs);
  	} else
  		return;			/* art was accepted */
--- 325,333 ----
  			history(art, NOLOG);
  		prefuse(art);
! 		(void) printf("no subscribed groups in `%s'\n", ngs);
! 	} else if (art->h.h_approved == NULL && moderated(ngs)) {
  		prefuse(art);
  		(void) printf("unapproved article in moderated group(s) `%s'\n",
! 			ngs);
  	} else
  		return;			/* art was accepted */

*** cnpatch/old/relay/relaynews.c	Thu Sep 14 16:03:51 1989
--- relay/relaynews.c	Wed Nov  1 14:26:33 1989
***************
*** 410,415 ****
  	if (c == '#')
  		return unbatch(in, inname);
! 	else
! 		return cpinsart(in, inname, MAXLONG, NO);
  }
  
--- 410,424 ----
  	if (c == '#')
  		return unbatch(in, inname);
! 	else {
! 		register long infinite = MAXLONG;
! 
! 		if (infinite <= 0) {		/* paranoia */
! 			errno = 0;
! 			errunlock(
! 			"MAXLONG is non-positive; rebuild the news software",
! 				"");
! 		}
! 		return cpinsart(in, inname, infinite, NO);
! 	}
  }
  

*** cnpatch/old/relay/sys.c	Thu Aug 24 16:40:07 1989
--- relay/sys.c	Thu Oct  5 05:14:06 1989
***************
*** 32,38 ****
  
  /* imports */
! extern boolean justone;
  extern struct system *mysysincache();
! extern void rewsys(), remmysys(), freecurrsys();
  
  struct system *
--- 32,38 ----
  
  /* imports */
! extern boolean donesys();
  extern struct system *mysysincache();
! extern void rewsys(), remmysys(), advcurrsys(), setupsys();
  
  struct system *
***************
*** 66,75 ****
  /*
   * Return the next sys entry, which may span multiple lines.
!  * Returned pointer points at a static struct whose members
!  * point at static storage.
   *
!  * It would be clearer to rewrite the justone/nextsys/readsys dance
!  * to get rid of justone, but I haven't the energy.  Sorry.  Beware that
!  * justone is set in either ../libbig/sys.fast.c or ../libsmall/sys.slow.c.
   */
  struct system *
--- 66,75 ----
  /*
   * Return the next sys entry, which may span multiple lines.
!  * Returned pointer points at a struct whose lifetime (and that of its
!  * members) is not promised to last beyond the next call to nextsys();
!  * copy it and its pointed-to strings if you need them for longer.
   *
!  * Note that readsys() reads one entry on small systems, but the entire
!  * sys file on big systems, so the common code in this file is subtle.
   */
  struct system *
***************
*** 84,89 ****
  		readsys();
  	retsys = currsys;
! 	if (currsys != NULL)
! 		currsys = currsys->sy_next;
  	return retsys;
  }
--- 84,88 ----
  		readsys();
  	retsys = currsys;
! 	advcurrsys();
  	return retsys;
  }
***************
*** 90,94 ****
  
  /*
!  * If justone, read one entry; else read whole sys file (done once only).
   * Ignores '#' comments and blank lines; uses cfgetms to read possibly-
   * continued lines of arbitrary length.
--- 89,93 ----
  
  /*
!  * On small systems, read one entry; else read whole sys file (done once only).
   * Ignores '#' comments and blank lines; uses cfgetms to read possibly-
   * continued lines of arbitrary length.
***************
*** 99,106 ****
  	register char *sysline;
  
! 	if (justone)
! 		freecurrsys();
! 	else
! 		rewind(fp);
  	while ((sysline = cfgetms(fp)) != NULL) {
  		if (sysline[0] != '#' && sysline[0] != '\n')
--- 98,102 ----
  	register char *sysline;
  
! 	setupsys(fp);		/* reuse currsys or rewind sys file */
  	while ((sysline = cfgetms(fp)) != NULL) {
  		if (sysline[0] != '#' && sysline[0] != '\n')
***************
*** 107,114 ****
  			parsesysln(sysline);
  		free(sysline);
! 		if (justone && firstsys != NULL) {	/* parsed an entry */
! 			firstsys = NULL;
  			return;
- 		}
  	}
  	(void) nfclose(fp);
--- 103,108 ----
  			parsesysln(sysline);
  		free(sysline);
! 		if (donesys())		/* early exit if on disk (small) */
  			return;
  	}
  	(void) nfclose(fp);
***************
*** 121,125 ****
  /*
   * Parse (and modify) sysline into *currsys, which is malloced here
!  * and freed iff "justone", in readsys(), see freecursys().
   *
   * Side-effect: sysline has a trailing newline removed.
--- 115,119 ----
  /*
   * Parse (and modify) sysline into *currsys, which is malloced here
!  * and freed iff on a small system, in readsys(), see freecursys().
   *
   * Side-effect: sysline has a trailing newline removed.
***************
*** 153,160 ****
  
  	/* stash *sysp away on the tail of the current list of systems */
! 	if (firstsys == NULL)
! 		firstsys = sysp;
! 	else
! 		currsys->sy_next = sysp;
  	currsys = sysp;
  }
--- 147,151 ----
  
  	/* stash *sysp away on the tail of the current list of systems */
! 	*(firstsys == NULL? &firstsys: &currsys->sy_next) = sysp;
  	currsys = sysp;
  }
***************
*** 211,215 ****
  /*
   * Parse "next" to colon into malloced storage, return its ptr via "into".
!  * *into is freed iff "justone", in readsys(), see freecursys().
   */
  STATIC void
--- 202,206 ----
  /*
   * Parse "next" to colon into malloced storage, return its ptr via "into".
!  * *into is freed iff on a small system, in readsys(), see freecursys().
   */
  STATIC void

*** cnpatch/old/rna/active.c	Tue Jun 20 19:01:47 1989
--- rna/active.c	Mon Oct 23 21:51:15 1989
***************
*** 3,8 ****
   *
   * format of file:
!  *	<groupname> ' ' <5 digit #> ' ' <5 digit #> ' ' flag '\n'
!  *			  (seq)		  (low)
   */
  
--- 3,8 ----
   *
   * format of file:
!  *	<groupname> ' ' <#> ' ' <#> ' ' flag '\n'
!  *			(seq)	(low)
   */
  
***************
*** 23,29 ****
  {
  	register FILE	*f;
! 	register int i;
  	char gbuf[BUFSIZ / 2], dbuf[BUFSIZ / 4], dbuf2[BUFSIZ / 4];
! 	extern char *itoa();
  
  	f = fopenl(actname);
--- 23,29 ----
  {
  	register FILE	*f;
! 	register long l;
  	char gbuf[BUFSIZ / 2], dbuf[BUFSIZ / 4], dbuf2[BUFSIZ / 4];
! 	extern char *itoa(), *ltoa();
  
  	f = fopenl(actname);
***************
*** 31,45 ****
  	while (getline(f, gbuf, dbuf, dbuf2))
  		if (CMP(gbuf, group) == 0) {
! 			i = atoi(dbuf);
! 			i++;
! 			fseek(f, -12L, 1);
! 			(void) fprintf(f, "%05d", i);
! 			fclose(f);
  #if !AUSAM
  			unlock(actname);
  #endif
! 			return itoa(i);
  		}
! 	(void) fprintf(f, "%s 00001 00001 y\n", group);
  	fclose(f);
  #if !AUSAM
--- 31,44 ----
  	while (getline(f, gbuf, dbuf, dbuf2))
  		if (CMP(gbuf, group) == 0) {
! 			l = atol(dbuf) + 1;
! 			(void) fseek(f, -(long)(2*(10+1)), 1);	/* TODO: fix this */
! 			(void) fprintf(f, "%010d", l);		/* TODO: fix this */
! 			(void) fclose(f);
  #if !AUSAM
  			unlock(actname);
  #endif
! 			return ltoa(l);
  		}
! 	(void) fprintf(f, "%s 0000000000 0000000001 y\n", group);
  	fclose(f);
  #if !AUSAM
***************
*** 49,53 ****
  }
  
- 
  static
  getline(f, g, d, d2)
--- 48,51 ----
***************
*** 97,101 ****
  	char gbuf[BUFSIZ / 2], dbuf[BUFSIZ / 4], dbuf2[BUFSIZ / 4];
  
! 	alist = last = NIL(active);
  	f = fopenf(actname, "r");
  	lineno = 0;
--- 95,99 ----
  	char gbuf[BUFSIZ / 2], dbuf[BUFSIZ / 4], dbuf2[BUFSIZ / 4];
  
! 	alist = last = NULL;
  	f = fopenf(actname, "r");
  	lineno = 0;
***************
*** 103,109 ****
  		ap = NEW(active);
  		ap->a_name = newstr(gbuf);
! 		ap->a_seq = atoi(dbuf);
! 		ap->a_low = atoi(dbuf2);
! 		ap->a_next = NIL(active);
  		if (!alist)
  			alist = ap;
--- 101,107 ----
  		ap = NEW(active);
  		ap->a_name = newstr(gbuf);
! 		ap->a_seq = atol(dbuf);
! 		ap->a_low = atol(dbuf2);
! 		ap->a_next = NULL;
  		if (!alist)
  			alist = ap;
***************
*** 148,153 ****
  	while (getline(f, gbuf, dbuf, dbuf2))
  		if (CMP(gbuf, group) == 0) {
! 			fseek(f, -6L, 1);
! 			(void) fprintf(f, "%05d", low);
  			break;
  		}
--- 146,151 ----
  	while (getline(f, gbuf, dbuf, dbuf2))
  		if (CMP(gbuf, group) == 0) {
! 			fseek(f, -(long)(10+1), 1);	/* TODO: fix this */
! 			(void) fprintf(f, "%010d", low); /* TODO: fix this */
  			break;
  		}
***************
*** 158,163 ****
  }
  
- 
- 
  /*
   * initgrp - initialise an entry for this group
--- 156,159 ----
***************
*** 178,182 ****
  			return;
  		}
! 	(void) fprintf(f, "%s 00000 00001\n", group);
  
  }
--- 174,178 ----
  			return;
  		}
! 	(void) fprintf(f, "%s 0000000000 0000000001\n", group);
  
  }

*** cnpatch/old/rna/defs.h	Tue Jun 20 19:01:48 1989
--- rna/defs.h	Mon Oct 23 21:33:25 1989
***************
*** 42,46 ****
  					   allows "-s subject -i include_file"
  					   arguments */
! #define NETID "utzoo"
  #ifndef NETID
  #define NETID "utstat"			/* else define it here */
--- 42,46 ----
  					   allows "-s subject -i include_file"
  					   arguments */
! #define NETID "utstat"
  #ifndef NETID
  #define NETID "utstat"			/* else define it here */
***************
*** 72,76 ****
  
  #define MYDOMAIN "uucp"			/* Local domain */
! #define MYORG	"U of Toronto Zoology" /* My organization */
  #define NEWSROOT "news"			/* news editor */
  
--- 72,76 ----
  
  #define MYDOMAIN "uucp"			/* Local domain */
! #define MYORG	"U of Toronto Statistics" /* My organization */
  #define NEWSROOT "news"			/* news editor */
  
***************
*** 142,147 ****
  struct active {
  	char	*a_name;
! 	short	a_seq;
! 	short	a_low;
  	active	*a_next;
  };
--- 142,147 ----
  struct active {
  	char	*a_name;
! 	long	a_seq;
! 	long	a_low;
  	active	*a_next;
  };
***************
*** 154,158 ****
  	char	*n_name;
  	bool	n_subscribe;
! 	short	n_last;
  	newsrc	*n_next;
  };
--- 154,158 ----
  	char	*n_name;
  	bool	n_subscribe;
! 	long	n_last;
  	newsrc	*n_next;
  };
***************
*** 159,163 ****
  
  char	*strrchr(), *strchr(), *strcat(), *strcpy(), *strpbrk();
! char	*itoa(), *convg(), *ngsquash(), *ttoa(), *mgets(), *rconvg();
  char	*newstr(), *newstr2(), *newstr3(), *newstr4(), *newstr5(), *catstr();
  char	*catstr2(), *bsearch(), *mtempnam(), *newstr6();
--- 159,163 ----
  
  char	*strrchr(), *strchr(), *strcat(), *strcpy(), *strpbrk();
! char	*itoa(), *ltoa(), *convg(), *ngsquash(), *ttoa(), *mgets(), *rconvg();
  char	*newstr(), *newstr2(), *newstr3(), *newstr4(), *newstr5(), *catstr();
  char	*catstr2(), *bsearch(), *mtempnam(), *newstr6();

*** cnpatch/old/rna/funcs.c	Tue Jun 20 19:01:50 1989
--- rna/funcs.c	Mon Oct 23 21:14:21 1989
***************
*** 212,216 ****
  }
  
- 
  /*
   * get unique sequence number from SEQ
--- 212,215 ----
***************
*** 220,235 ****
  {
  	register long number;
! 	register FILE	*f;
  	static char buf[12];
  
  	f = fopenl(SEQ);
! 	if (fread(buf, 1, sizeof(buf), f) > 0)
  		number = atol(buf);
  	else
  		number = 1;
- 
  	rewind(f);
  	(void) fprintf(f, "%ld\n", number + 1);
! 	fclose(f);
  #if !AUSAM
  	unlock(SEQ);
--- 219,233 ----
  {
  	register long number;
! 	register FILE *f;
  	static char buf[12];
  
  	f = fopenl(SEQ);
! 	if (fread(buf, 1, sizeof buf, f) > 0)
  		number = atol(buf);
  	else
  		number = 1;
  	rewind(f);
  	(void) fprintf(f, "%ld\n", number + 1);
! 	(void) fclose(f);
  #if !AUSAM
  	unlock(SEQ);
***************
*** 240,244 ****
  }
  
- 
  /*
   * open a locked file (or create) for reading and writing
--- 238,241 ----
***************
*** 248,260 ****
  char *fname;
  {
! 	register FILE	*f;
  #ifdef AUSAM
  	struct stat sbuf;
  #endif
  
! 	extern uid_t	newsuid;
! 
! 	if ((f = fopen(fname, "r+")) == NIL(FILE) && (f = fopen(fname, "w+")) ==
! 	    NIL(FILE))
  		error("Can't open %s", fname);
  
--- 245,256 ----
  char *fname;
  {
! 	register FILE *f;
  #ifdef AUSAM
  	struct stat sbuf;
  #endif
+ 	extern uid_t newsuid;
  
! 	if ((f = fopen(fname, "r+")) == NULL &&
! 	    (f = fopen(fname, "w+")) == NULL)
  		error("Can't open %s", fname);
  
***************
*** 262,268 ****
  	if (fstat(fileno(f), &sbuf) != 0)
  		error("Can't stat %s", fname);
! 	if ((sbuf.st_mode & S_IFMT) != S_IFALK && (chmod(fname, (int) (sbuf.st_mode
! 	    &~S_IFMT) | S_IFALK) != 0 || chown(fname, (int) newsuid, (int) newsuid) !=
! 	    0 || fclose(f) == EOF || (f = fopen(fname, "r+")) == NIL(FILE)))
  		error("Can't create %s", fname);
  #else
--- 258,266 ----
  	if (fstat(fileno(f), &sbuf) != 0)
  		error("Can't stat %s", fname);
! 	if ((sbuf.st_mode & S_IFMT) != S_IFALK &&
! 	    (chmod(fname, (int)(sbuf.st_mode&~S_IFMT) | S_IFALK) != 0 ||
! 	    chown(fname, (int)newsuid, (int)newsuid) != 0 ||
! 	    fclose(f) == EOF ||
! 	    (f = fopen(fname, "r+")) == NULL))
  		error("Can't create %s", fname);
  #else
***************
*** 320,324 ****
  	register FILE	*f;
  
! 	if ((f = fopen(name, mode)) == NIL(FILE))
  		error("Can't %s %s", *mode == 'r' ? "open" : "create", name);
  	return f;
--- 318,322 ----
  	register FILE	*f;
  
! 	if ((f = fopen(name, mode)) == NULL)
  		error("Can't %s %s", *mode == 'r' ? "open" : "create", name);
  	return f;
***************
*** 369,373 ****
  
  	fflush(stdout);
! 	if (fgets(buf, sizeof(buf), stdin) == NIL(char)) {
  		(void) printf("\n");
  		return NIL(char);
--- 367,371 ----
  
  	fflush(stdout);
! 	if (fgets(buf, sizeof(buf), stdin) == NULL) {
  		(void) printf("\n");
  		return NIL(char);
***************
*** 376,383 ****
  		while (isspace(*s) && s > buf)
  			*s-- = '\0';
! 	else
! 	 {
  		(void) printf("Input line too long.\n");
! 		return NIL(char);
  	}
  	s = buf;
--- 374,380 ----
  		while (isspace(*s) && s > buf)
  			*s-- = '\0';
! 	else {
  		(void) printf("Input line too long.\n");
! 		return NULL;
  	}
  	s = buf;
***************
*** 531,535 ****
  char *path;
  {
! 	FILE		 * f;
  	register char *ex1, *ex2, *com, *new;
  	char buf[BUFSIZ];
--- 528,532 ----
  char *path;
  {
! 	FILE *f;
  	register char *ex1, *ex2, *com, *new;
  	char buf[BUFSIZ];
***************
*** 540,545 ****
  		if ((f = popen(com, "r")) == NIL(FILE))
  			(void) printf("Couldn't run \"%s\"\n", com);
! 		else
! 		 {
  			fread(buf, sizeof(buf), 1, f);
  			if (pclose(f) != 0) {
--- 537,541 ----
  		if ((f = popen(com, "r")) == NIL(FILE))
  			(void) printf("Couldn't run \"%s\"\n", com);
! 		else {
  			fread(buf, sizeof(buf), 1, f);
  			if (pclose(f) != 0) {
***************
*** 558,562 ****
  	}
  	return path;
- 
  }
  
--- 554,557 ----
***************
*** 571,577 ****
  register char *sp;
  {
! 	register char *sep;
  
- 	sep = NIL(char);
  	while (*sp) {
  		if (sep)
--- 566,571 ----
  register char *sp;
  {
! 	register char *sep = NULL;
  
  	while (*sp) {
  		if (sep)
***************
*** 586,589 ****
  	}
  }
- 
- 
--- 580,581 ----

*** cnpatch/old/rna/header.c	Tue Jun 20 19:01:51 1989
--- rna/header.c	Mon Oct 23 20:50:27 1989
***************
*** 111,115 ****
  	field		af;
  	char buf[BUFLEN*2];
- 
  	char *hfgets();
  
--- 111,114 ----
***************
*** 118,131 ****
  		if (buf[0] == '\n')
  			return;
! 		if (isupper(buf[0]) && (colon = strchr(buf, ':')) && (space =
! 		    strchr(buf, ' ')) && (colon + 1 == space)) {
  			*colon = '\0';
  			af.f_name = buf;
! 			fp = (field * ) bsearch((char *) & af, (char *) fields,
! 			     				sizeof(fields) / sizeof(fields[0]), sizeof(fields[0]),
! 			     fieldcmp);
  			*colon = ':';
  		} else
! 			fp = NIL(field);
  		if (!fp)
  			if (hp->h_others)
--- 117,130 ----
  		if (buf[0] == '\n')
  			return;
! 		if (isupper(buf[0]) && (colon = strchr(buf, ':')) &&
! 		    (space = strchr(buf, ' ')) && (colon + 1 == space)) {
  			*colon = '\0';
  			af.f_name = buf;
! 			fp = (field * )bsearch((char *)&af, (char *)fields,
! 				sizeof fields/sizeof fields[0], sizeof fields[0],
! 				fieldcmp);
  			*colon = ':';
  		} else
! 			fp = NULL;
  		if (!fp)
  			if (hp->h_others)
***************
*** 133,138 ****
  			else
  				hp->h_others = newstr(buf);
! 		else
! 		 {
  			if (colon = strchr(space + 1, '\n'))
  				*colon = '\0';
--- 132,136 ----
  			else
  				hp->h_others = newstr(buf);
! 		else {
  			if (colon = strchr(space + 1, '\n'))
  				*colon = '\0';
***************
*** 394,399 ****
  	register char *cp, *tp;
  
! 	if ((cp = fgets(buf, len, fp)) == NIL(char))
! 		return NIL(char);
  
  	if (*cp == '\n')
--- 392,397 ----
  	register char *cp, *tp;
  
! 	if ((cp = fgets(buf, len, fp)) == NULL)
! 		return NULL;
  
  	if (*cp == '\n')
***************
*** 445,449 ****
  	     tp->tm_sec, tzone);
  	return buf;
- 
  }
  
--- 443,446 ----
***************
*** 474,477 ****
  	return maketime(4, argv, STIMES);
  }
- 
- 
--- 471,472 ----

*** cnpatch/old/rna/history.c	Tue Jun 20 19:01:52 1989
--- rna/history.c	Mon Oct 23 21:35:49 1989
***************
*** 168,175 ****
  
  	f = fopenl(histname);
! 	fseek(f, 0L, 2);
! 	(void) fprintf(f, "%s %s%ld %s\n", histid, etime ? "E" : "", etime ? etime :
! 	    now, histline);
! 	fclose(f);
  #if !AUSAM
  	unlock(histname);
--- 168,175 ----
  
  	f = fopenl(histname);
! 	(void) fseek(f, 0L, 2);
! 	(void) fprintf(f, "%s %s%ld %s\n", histid, (etime? "E": ""),
! 		(etime? (long)etime: now), histline);
! 	(void) fclose(f);
  #if !AUSAM
  	unlock(histname);

*** cnpatch/old/rna/lib/itoa.c	Tue Jun 20 19:01:53 1989
--- rna/lib/itoa.c	Mon Oct 23 21:55:01 1989
***************
*** 8,9 ****
--- 8,19 ----
  	return buf;
  }
+ 
+ char *
+ ltoa(l)
+ long l;
+ {
+ 	static char buf[30];
+ 
+ 	sprintf(buf, "%ld", l);
+ 	return buf;
+ }

*** cnpatch/old/rna/makefile	Thu Aug 24 16:40:08 1989
--- rna/makefile	Mon Oct 23 20:55:25 1989
***************
*** 24,29 ****
  FILES = help
  LCOMMANDS = postnews.lint uurec.lint readnews.lint uusend.lint expire.lint
! # PFILES = header.c postnews.c funcs.c active.c history.c maketime.c mtempnam.c
! PFILES = header.c funcs.c active.c history.c maketime.c mtempnam.c
  RFILES = header.c readnews.c funcs.c active.c newsrc.c history.c maketime.c
  ROFILES= header.o readnews.o funcs.o active.o newsrc.o history.o maketime.o
--- 24,29 ----
  FILES = help
  LCOMMANDS = postnews.lint uurec.lint readnews.lint uusend.lint expire.lint
! # PFILES = header.c postnews.c funcs.c active.c history.c maketime.c
! PFILES = header.c funcs.c active.c history.c maketime.c
  RFILES = header.c readnews.c funcs.c active.c newsrc.c history.c maketime.c
  ROFILES= header.o readnews.o funcs.o active.o newsrc.o history.o maketime.o

*** cnpatch/old/rna/maketime.c	Tue Jun 20 19:01:57 1989
--- rna/maketime.c	Mon Oct 23 21:20:36 1989
***************
*** 396,400 ****
  }
  
- 
  static long 
  construct()
--- 396,399 ----
***************
*** 411,418 ****
  	if (setdayofweek)
  		days += dayofweek;
! 	return days * SECINDAY + hour * SECINHOUR + minute * SECINMIN + second;
  }
  
- 
  static
  adjust()
--- 410,416 ----
  	if (setdayofweek)
  		days += dayofweek;
! 	return (long)days*SECINDAY + (long)hour*SECINHOUR + minute*SECINMIN + second;
  }
  
  static
  adjust()
***************
*** 442,447 ****
  	 * month == tim->tm_mon && day == tim->tm_mday
  	 */
! 	if ((long)(hour*SECINHOUR + minute*SECINMIN + second) <
! 	    (long)(tim->tm_hour*SECINHOUR + tim->tm_min*SECINMIN + tim->tm_sec)) {
  		dim = daysinmonth[month] + (month == 1? leapyear(month): 0);
  		if (setday || ++day / dim) {
--- 440,445 ----
  	 * month == tim->tm_mon && day == tim->tm_mday
  	 */
! 	if ((long)hour*SECINHOUR + minute*SECINMIN + second <
! 	    (long)tim->tm_hour*SECINHOUR + tim->tm_min*SECINMIN + tim->tm_sec) {
  		dim = daysinmonth[month] + (month == 1? leapyear(month): 0);
  		if (setday || ++day / dim) {
***************
*** 453,456 ****
  	}
  }
- 
- 
--- 451,452 ----

*** cnpatch/old/rna/newsrc.c	Tue Jun 20 19:01:59 1989
--- rna/newsrc.c	Mon Oct 23 21:02:59 1989
***************
*** 168,175 ****
  			if (!ngmatch(ap->a_name, group))
  				continue;
! 			if ((np = findnewsrc(ap->a_name)) == NIL(newsrc)) {
  				np = NEW(newsrc);
  				np->n_name = newstr(ap->a_name);
! 				np->n_next = NIL(newsrc);
  				np->n_last = 0;
  				np->n_subscribe = true;
--- 168,175 ----
  			if (!ngmatch(ap->a_name, group))
  				continue;
! 			if ((np = findnewsrc(ap->a_name)) == NULL) {
  				np = NEW(newsrc);
  				np->n_name = newstr(ap->a_name);
! 				np->n_next = NULL;
  				np->n_last = 0;
  				np->n_subscribe = true;
***************
*** 212,216 ****
  
  /*
!  * find if a newrc entry exists,
   * taking advantange of the fact that requests should be
   * in the same order
--- 212,216 ----
  
  /*
!  * find if a newsrc entry exists,
   * taking advantange of the fact that requests should be
   * in the same order
***************
*** 228,232 ****
  
  	if (!rc)
! 		return NIL(newsrc);
  
  	found = false;
--- 228,232 ----
  
  	if (!rc)
! 		return NULL;
  
  	found = false;
***************
*** 295,298 ****
--- 295,299 ----
  static
  writengline(f, np)		/* write .newsrc n.g. line in normal form on f */
+ FILE *f;
  register newsrc *np;
  {

*** cnpatch/old/rna/readnews.c	Tue Jun 20 19:02:10 1989
--- rna/readnews.c	Mon Oct 23 21:57:42 1989
***************
*** 458,462 ****
  	np->n_last++;
  	fname = convg(newstr5(newsdir, "/", ap->a_name, ARTSEP,
! 		itoa(np->n_last)));
  	ino = 0;
  	f = fopen(fname, "r");
--- 458,462 ----
  	np->n_last++;
  	fname = convg(newstr5(newsdir, "/", ap->a_name, ARTSEP,
! 		ltoa(np->n_last)));
  	ino = 0;
  	f = fopen(fname, "r");
***************
*** 493,500 ****
  {
  	static bool done;
- 	register int num;
  
  	np->n_last++;
  	if (Cflag) {
  		if (!done)
  			(void) printf("You have news:\n");
--- 493,501 ----
  {
  	static bool done;
  
  	np->n_last++;
  	if (Cflag) {
+ 		register long num;
+ 
  		if (!done)
  			(void) printf("You have news:\n");
***************
*** 501,505 ****
  		done = true;
  		num = ap->a_seq - np->n_last + 1;
! 		(void) printf("\t%s at most %d article%s\n",
  			ap->a_name, num, (num > 1? "s": ""));
  		return nextgroup;
--- 502,506 ----
  		done = true;
  		num = ap->a_seq - np->n_last + 1;
! 		(void) printf("\t%s at most %ld article%s\n",
  			ap->a_name, num, (num > 1? "s": ""));
  		return nextgroup;
***************
*** 511,515 ****
  }
  
- 
  /*
   * normal command handler (or pflag)
--- 512,515 ----
***************
*** 548,563 ****
  bool pushed;
  {
- 	static char errmess[] = "Incorrect command; Type `?' for help.\n";
- 	static char form[]    = "%s: %s\n";
- 
- 	static char savedsys[BUFSIZ / 2];
- 	static active	*lastap, *rlastap;
- 	static newsrc	lastn;
- 	static char number[20];
- 	static active	*wantap;
- 
  	register char *com, *arg;
! 	register int c, i, size;
! 	register FILE 	*f;
  	char *fname;
  	header		h;
--- 548,555 ----
  bool pushed;
  {
  	register char *com, *arg;
! 	register int c, size;
! 	register long i;
! 	register FILE *f;
  	char *fname;
  	header		h;
***************
*** 566,570 ****
  	bool printed, pheader, verbose, hadinterrupt;
  	applycom	nextact;
! 
  	extern char t_from[], t_subject[], t_date[];
  	extern char t_newsgroups[], t_path[], t_sender[];
--- 558,568 ----
  	bool printed, pheader, verbose, hadinterrupt;
  	applycom	nextact;
! 	static char errmess[] = "Incorrect command; Type `?' for help.\n";
! 	static char form[]    = "%s: %s\n";
! 	static char savedsys[BUFSIZ / 2];
! 	static active	*lastap, *rlastap;
! 	static newsrc	lastn;
! 	static char number[20];
! 	static active	*wantap;
  	extern char t_from[], t_subject[], t_date[];
  	extern char t_newsgroups[], t_path[], t_sender[];
***************
*** 573,577 ****
  	extern active	*activep();
  
- 
  	if (last) {
  		/*
--- 571,574 ----
***************
*** 591,598 ****
  			return nextgroup;
  		else
! 			wantap = NIL(active);
  
  	fname = convg(newstr5(newsdir, "/", ap->a_name, ARTSEP,
! 		itoa(np->n_last + 1)));
  	f = fopen(fname, "r");
  	ino = 0;
--- 588,595 ----
  			return nextgroup;
  		else
! 			wantap = NULL;
  
  	fname = convg(newstr5(newsdir, "/", ap->a_name, ARTSEP,
! 		ltoa(np->n_last + 1)));
  	f = fopen(fname, "r");
  	ino = 0;
***************
*** 599,603 ****
  	if (!f || !last && !pushed && seen(f, &ino)) {
  		if (pushed)
! 			(void) printf("Article %d (%s) no longer exists.\n",
  				np->n_last + 1, ap->a_name);
  		else
--- 596,600 ----
  	if (!f || !last && !pushed && seen(f, &ino)) {
  		if (pushed)
! 			(void) printf("Article %ld (%s) no longer exists.\n",
  				np->n_last + 1, ap->a_name);
  		else
***************
*** 639,643 ****
  		lastap = ap;
  		if (!pheader) {
! 			(void) printf("Article %d of %d (%s)",
  				np->n_last + 1, ap->a_seq, ap->a_name);
  			if (h.h_lines != 0)
--- 636,640 ----
  		lastap = ap;
  		if (!pheader) {
! 			(void) printf("Article %ld of %ld (%s)",
  				np->n_last + 1, ap->a_seq, ap->a_name);
  			if (h.h_lines != 0)
***************
*** 671,676 ****
  			 */
  			com = "";
! 		else
! 		 {
  			(void) printf("? ");
  			if (fflush(stdout) == EOF) {
--- 668,672 ----
  			 */
  			com = "";
! 		else {
  			(void) printf("? ");
  			if (fflush(stdout) == EOF) {
***************
*** 775,780 ****
  #endif
  				 {
! 					(void) printf("Group \"%s\" can't be unsubscribed.\n",
! 					     					 np->n_name);
  					continue;
  				}
--- 771,777 ----
  #endif
  				 {
! 					(void) printf(
! 					"Group \"%s\" can't be unsubscribed.\n",
! 						np->n_name);
  					continue;
  				}
***************
*** 797,801 ****
  			if (!ngmatch(arg, nflag)) {
  				(void) printf("%s: is not subscribed to!\n", arg);
! 				wantap = NIL(active);
  				continue;
  			}
--- 794,798 ----
  			if (!ngmatch(arg, nflag)) {
  				(void) printf("%s: is not subscribed to!\n", arg);
! 				wantap = NULL;
  				continue;
  			}
***************
*** 833,837 ****
  			while (number[0]) {
  				ntmp = lastn;
! 				ntmp.n_last = atoi(number) - 1;
  				number[0] = '\0';
  				nextact = commands(rlastap, &ntmp, false, true);
--- 830,834 ----
  			while (number[0]) {
  				ntmp = lastn;
! 				ntmp.n_last = atol(number) - 1;
  				number[0] = '\0';
  				nextact = commands(rlastap, &ntmp, false, true);
***************
*** 844,847 ****
--- 841,845 ----
  		default:
  			if (isdigit(c)) {
+ /*				i = atol(arg);		*/
  				i = c - '0';
  				while (isdigit(*arg))
***************
*** 854,863 ****
  			number[0] = '\0';
  			if (i < ap->a_low || i > ap->a_seq) {
! 				(void) printf("Articles in \"%s\" group range %d to %d.\n",
! 				     					np->n_name, ap->a_low, ap->a_seq);
  				continue;
  			}
  			if (pushed) {
! 				sprintf(number, "%d", i);
  				nextact = next;
  				break;
--- 852,862 ----
  			number[0] = '\0';
  			if (i < ap->a_low || i > ap->a_seq) {
! 				(void) printf(
! 				    "Articles in \"%s\" group range %ld to %ld.\n",
! 				    np->n_name, ap->a_low, ap->a_seq);
  				continue;
  			}
  			if (pushed) {
! 				sprintf(number, "%ld", i);
  				nextact = next;
  				break;
***************
*** 865,870 ****
  			ntmp = *np;
  			ntmp.n_last = i - 1;
! 			if ((nextact = commands(ap, &ntmp, false, true)) !=
! 			    next)
  				break;
  			if (!number[0]) {
--- 864,868 ----
  			ntmp = *np;
  			ntmp.n_last = i - 1;
! 			if ((nextact = commands(ap, &ntmp, false, true)) != next)
  				break;
  			if (!number[0]) {
***************
*** 889,893 ****
  }
  
- 
  /*
   * see if this is a followup we are ignoring
--- 887,890 ----
***************
*** 1259,1263 ****
  			id++;
  	}
! 	qsort((char *) uflag, (unsigned) usize, sizeof(char *), strpcmp);
  }
  
--- 1256,1260 ----
  			id++;
  	}
! 	qsort((char *)uflag, (unsigned)usize, sizeof(char *), strpcmp);
  }
  
***************
*** 1266,1269 ****
--- 1263,1267 ----
   * print an article, if it's long enough call page()
   */
+ /* ARGSUSED */
  print(hp, f)
  header *hp;
***************
*** 1276,1282 ****
  	if (!pflag
  #ifdef LINESHDRPRESENT
! 	 && hp->h_lines && atoi(hp->h_lines) >= PAGESIZE - 4
  #endif
! 	 )
  		page(f);
  	else
--- 1274,1280 ----
  	if (!pflag
  #ifdef LINESHDRPRESENT
! 	    && hp->h_lines && atoi(hp->h_lines) >= PAGESIZE - 4
  #endif
! 	    )
  		page(f);
  	else
***************
*** 1283,1287 ****
  		while ((c = getc(f)) != EOF)
  			(void) putchar(c);
! 	fseek(f, pos, 0);
  }
  
--- 1281,1285 ----
  		while ((c = getc(f)) != EOF)
  			(void) putchar(c);
! 	(void) fseek(f, pos, 0);
  }
  


end of patch 13-Nov-1989
